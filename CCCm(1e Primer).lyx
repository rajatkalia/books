#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\begin_modules
endnotes
hanging
logicalmkup
theorems-std
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize b3paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1.25in
\rightmargin 1in
\bottommargin 1.25in
\secnumdepth 3
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
A Complete Course in Computers - First Edition Primer
\end_layout

\begin_layout Author
Manas Kalia and Rajat Kalia
\end_layout

\begin_layout Date
7 December, 2017
\end_layout

\begin_layout Part*
Computer Hardware ( alongwith Handhelds )
\end_layout

\begin_layout Part
The CPU, Memory and Power
\end_layout

\begin_layout Part
The Motherboard
\end_layout

\begin_layout Part
Assembly Language
\end_layout

\begin_layout Part
Basic Analogy of a Handheld
\end_layout

\begin_layout Chapter
Types of Handhelds alongwith History
\end_layout

\begin_layout Section
Pager
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter
The Camera
\end_layout

\begin_layout Part*
Operating Systems
\end_layout

\begin_layout Part
Microsoft Windows
\end_layout

\begin_layout Part
Unix and Linux Flavours
\end_layout

\begin_layout Part
Android OS ( For Mobiles )
\end_layout

\begin_layout Part*
Programming
\end_layout

\begin_layout Part
History of Programming
\end_layout

\begin_layout Part
The C Programming Language
\end_layout

\begin_layout Part
The C++ and C#
\end_layout

\begin_layout Part
Java
\end_layout

\begin_layout Part*
Subtle Programming ( often called Scripting )
\end_layout

\begin_layout Part
The Perl Programming Language
\end_layout

\begin_layout Part
Javascript
\end_layout

\begin_layout Part*
Projects
\end_layout

\begin_layout Part
Todarmal ( A search Engine )
\end_layout

\begin_layout Standard
The project was later renamed tobu (with a new noticeboard image ) in it's
 later run at IIT Delhi while i was the Administrator.
 Near closure , it was handled by 
\begin_inset Quotes eld
\end_inset

kala
\begin_inset Quotes erd
\end_inset

 guy for one day owing to his bullying while on that day also it was installed
 by me only although he requested the technique of setting up the project
 be explained to him.
 Our team totally discredits them as all the contact email-id's had other
 names that day(As per law code can't be copyrighted).
 In my presence , the ownership circulated amongst Shitiz Bansal, Vikas
 Rana ,Rahul Jain(of Jwala), 2 Vivek Maliks ( one Raj(original amongst those
 two)and one Pig 
\begin_inset Quotes erd
\end_inset

Nishant Kumar
\begin_inset Quotes erd
\end_inset

(the copy)) and Vivek Shrivastav although Vivek was the name they were taking
 all the time, probably of Niraj Patel as setting the project was difficult
 and it was not possible for those people without Niraj Patel to set it
 up on the server (if crashed).
\end_layout

\begin_layout Standard
Programmed by Bill (Babbar Bhangoo) and discssed by him at Nahan, Problem
 Question worked on by Rajat (kalia).
 (2002 onwards)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//The driver.c file of Todarmal project to be stored in 
\begin_inset Quotes eld
\end_inset

src
\begin_inset Quotes erd
\end_inset

 folder
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include "myutil.h" 
\end_layout

\begin_layout Plain Layout

#include <sys/stat.h> 
\end_layout

\begin_layout Plain Layout

#include <dirent.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void rem_spaces(char *str) { 	
\end_layout

\begin_layout Plain Layout

		int flag,i,j; 	
\end_layout

\begin_layout Plain Layout

		// remove initial spaces 	
\end_layout

\begin_layout Plain Layout

		for(flag=i=j=0;i<strlen(str);i++) 	
\end_layout

\begin_layout Plain Layout

		{ 		
\end_layout

\begin_layout Plain Layout

				if(isspace(str[i]) && flag==0) 			
\end_layout

\begin_layout Plain Layout

						continue; 					
\end_layout

\begin_layout Plain Layout

				flag=1; 		
\end_layout

\begin_layout Plain Layout

				str[j++]=str[i]; 	
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

		str[j]='
\backslash
0'; 	
\end_layout

\begin_layout Plain Layout

		//remove trailing spaces 	
\end_layout

\begin_layout Plain Layout

		for(i=strlen(str)-1;i>=0;i--) 	
\end_layout

\begin_layout Plain Layout

		{ 		
\end_layout

\begin_layout Plain Layout

		if(isspace(str[i])) 			
\end_layout

\begin_layout Plain Layout

		str[i]='
\backslash
0'; 		
\end_layout

\begin_layout Plain Layout

		else break; 	
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int buildtree(char *share,char *name,char *ip, char *pid) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

		char treefile[256],command[256],mpoint[256]; 	
\end_layout

\begin_layout Plain Layout

		int ret,success,pprotect; 	
\end_layout

\begin_layout Plain Layout

		FILE *fp; 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		success=pprotect=0; 	
\end_layout

\begin_layout Plain Layout

		// pprotect = password protect 	
\end_layout

\begin_layout Plain Layout

		strcpy(mpoint,"/mnt/tmp/mpoint_"); 	
\end_layout

\begin_layout Plain Layout

		strcat(mpoint,pid); 	
\end_layout

\begin_layout Plain Layout

		strcpy(treefile,"../files/tmp/tree_"); 	
\end_layout

\begin_layout Plain Layout

		strcat(treefile,pid); 	
\end_layout

\begin_layout Plain Layout

		ret=mkdir(mpoint,S_IRUSR | S_IWUSR | S_IXUSR); 	
\end_layout

\begin_layout Plain Layout

		if(ret<0) 		
\end_layout

\begin_layout Plain Layout

				perror("Error in creating mount pt "); 	
\end_layout

\begin_layout Plain Layout

		strcpy(command,"/bin/tobumount "); 	
\end_layout

\begin_layout Plain Layout

		strcat(command,ip); 	
\end_layout

\begin_layout Plain Layout

		strcat(command," 
\backslash
""); 	
\end_layout

\begin_layout Plain Layout

		strcat(command,name); 			
\end_layout

\begin_layout Plain Layout

		strcat(command,"
\backslash
" 
\backslash
""); 	
\end_layout

\begin_layout Plain Layout

		strcat(command,share); 	
\end_layout

\begin_layout Plain Layout

		strcat(command,"
\backslash
" "); 	
\end_layout

\begin_layout Plain Layout

		strcat(command,pid); 	
\end_layout

\begin_layout Plain Layout

		fp=popen(command,"r"); 
\end_layout

\begin_layout Plain Layout

		// mount and see output of smbmount 	
\end_layout

\begin_layout Plain Layout

		if(fp==NULL) 		
\end_layout

\begin_layout Plain Layout

				perror("smbmount pipe error "); 	
\end_layout

\begin_layout Plain Layout

		while(fgets(command,256,fp)!=NULL) 	
\end_layout

\begin_layout Plain Layout

		{ 		
\end_layout

\begin_layout Plain Layout

		//if((char *)strstr(command,"ERRbadpw")!=NULL 		
\end_layout

\begin_layout Plain Layout

		//		||(char *)strstr(command,"ERRnoaccess")!=NULL) 		
\end_layout

\begin_layout Plain Layout

				if((char *)strstr(command,"ERRbadpw")!=NULL) 			
\end_layout

\begin_layout Plain Layout

				pprotect=1; 
\end_layout

\begin_layout Plain Layout

				// has got some passwd 		
\end_layout

\begin_layout Plain Layout

				else printf("SMBMNTOUT : %s",command); 	
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

		//if(pprotect==1) 	
\end_layout

\begin_layout Plain Layout

		//	printf("%s (%s) -> %s is passwd protected
\backslash
n",ip,name,share); 	
\end_layout

\begin_layout Plain Layout

		pclose(fp); 	
\end_layout

\begin_layout Plain Layout

		fp=fopen("/proc/mounts","r"); 	
\end_layout

\begin_layout Plain Layout

		// read /proc/mounts to see if u have been able to mount the share 	
\end_layout

\begin_layout Plain Layout

		if(fp==NULL) 		
\end_layout

\begin_layout Plain Layout

		perror("Error Can't read /proc/mounts "); 	
\end_layout

\begin_layout Plain Layout

		while(fgets(command,256,fp)!=NULL) 	
\end_layout

\begin_layout Plain Layout

		{ 		
\end_layout

\begin_layout Plain Layout

				if((char *)strstr(command,pid)!=NULL) 			
\end_layout

\begin_layout Plain Layout

				success=1; // so we have mounted that share 	
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

		fclose(fp); 	
\end_layout

\begin_layout Plain Layout

		if(success || pprotect) 	
\end_layout

\begin_layout Plain Layout

		{ 		
\end_layout

\begin_layout Plain Layout

				if(success==1) 		
\end_layout

\begin_layout Plain Layout

				{ 			
\end_layout

\begin_layout Plain Layout

						printf("Building tree %s (%s) -> %s
\backslash
n",ip,name,share); 			
\end_layout

\begin_layout Plain Layout

						fflush(stdout); 		
\end_layout

\begin_layout Plain Layout

				} 		
\end_layout

\begin_layout Plain Layout

				strcpy(command,"./tree "); 		
\end_layout

\begin_layout Plain Layout

				strcat(command,mpoint); // local mount point 		
\end_layout

\begin_layout Plain Layout

				strcat(command," > "); 		
\end_layout

\begin_layout Plain Layout

				strcat(command,treefile); 		
\end_layout

\begin_layout Plain Layout

				system(command); // build tree 		
\end_layout

\begin_layout Plain Layout

				strcpy(command,"/bin/tobufree "); // a root setuid script 		
\end_layout

\begin_layout Plain Layout

				strcat(command,pid); 		
\end_layout

\begin_layout Plain Layout

				if(success==1)  		
\end_layout

\begin_layout Plain Layout

						{	 			
\end_layout

\begin_layout Plain Layout

								system(command); // umount mpoint 		
\end_layout

\begin_layout Plain Layout

						} 	
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

				ret=rmdir(mpoint); // remove local mount pt 	
\end_layout

\begin_layout Plain Layout

				if(ret<0) 		
\end_layout

\begin_layout Plain Layout

				perror("Error in removing mount pt "); 	
\end_layout

\begin_layout Plain Layout

				return(success || pprotect); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

		void writename(char *name,char *ip) 
\end_layout

\begin_layout Plain Layout

		{ 	
\end_layout

\begin_layout Plain Layout

				/* takes name and ip and writes name to file "../files/names/ip" */ 	
\end_layout

\begin_layout Plain Layout

				FILE *fp; 	
\end_layout

\begin_layout Plain Layout

				char filename[256];
\end_layout

\begin_layout Plain Layout

				strcpy(filename,"../files/names/"); 	
\end_layout

\begin_layout Plain Layout

				strcat(filename,ip); 	
\end_layout

\begin_layout Plain Layout

				fp=fopen(filename,"w"); 	
\end_layout

\begin_layout Plain Layout

				if(fp==NULL) 	
\end_layout

\begin_layout Plain Layout

				{ 		
\end_layout

\begin_layout Plain Layout

						fprintf(stderr,"Error Can't write name %s for %s",name,ip); 		
\end_layout

\begin_layout Plain Layout

						perror(""); 		
\end_layout

\begin_layout Plain Layout

						return; 	
\end_layout

\begin_layout Plain Layout

				} 	
\end_layout

\begin_layout Plain Layout

				fprintf(fp,"%s",name); 	
\end_layout

\begin_layout Plain Layout

				fclose(fp); }
\end_layout

\begin_layout Plain Layout

				int findname(char *name,char *ip) 
\end_layout

\begin_layout Plain Layout

				{ 	
\end_layout

\begin_layout Plain Layout

						/*  	 * uses system command nmblookup to find name 	 * nmblookup is
 provided by smbclient  	 * for details go to http://www.samba.org 	 */ 	
\end_layout

\begin_layout Plain Layout

						FILE *pipe; 	
\end_layout

\begin_layout Plain Layout

						char command[256],input[256],temp[5]; 	
\end_layout

\begin_layout Plain Layout

						int success=0,i;
\end_layout

\begin_layout Plain Layout

						strcpy(command,"nmblookup -A "); 	
\end_layout

\begin_layout Plain Layout

						// system command : nmblookup -A ip_address 	
\end_layout

\begin_layout Plain Layout

						strcat(command,ip); 	pipe=popen(command,"r"); 
\end_layout

\begin_layout Plain Layout

						// run command and read output 	
\end_layout

\begin_layout Plain Layout

						while(fgets(input,256,pipe)!=NULL) 	
\end_layout

\begin_layout Plain Layout

						{ 		
\end_layout

\begin_layout Plain Layout

								if(((char *)strchr(input,'<')!=NULL)  				&& ((char*)strchr(input,'>')!=
NULL)) 			
\end_layout

\begin_layout Plain Layout

										success=1; // so comp was connected 		
\end_layout

\begin_layout Plain Layout

								if((char *)strstr(input,"<20>")==NULL) 			
\end_layout

\begin_layout Plain Layout

										continue; // skip lines not having <20> 		
\end_layout

\begin_layout Plain Layout

										// process only lines with <20> in them 		
\end_layout

\begin_layout Plain Layout

										// this line should have a name 		
\end_layout

\begin_layout Plain Layout

								for(i=0;i<strlen(input);i++) 		
\end_layout

\begin_layout Plain Layout

										{ 			
\end_layout

\begin_layout Plain Layout

												temp[0]=input[i]; 			
\end_layout

\begin_layout Plain Layout

												temp[1]=input[i+1]; 			
\end_layout

\begin_layout Plain Layout

												temp[2]=input[i+2]; 			
\end_layout

\begin_layout Plain Layout

												temp[3]=input[i+3]; 			
\end_layout

\begin_layout Plain Layout

												temp[4]='
\backslash
0'; 			
\end_layout

\begin_layout Plain Layout

												if(strcmp(temp,"<20>")==0) 			
\end_layout

\begin_layout Plain Layout

												{ 				
\end_layout

\begin_layout Plain Layout

														input[i]='
\backslash
0'; 				
\end_layout

\begin_layout Plain Layout

														break; 			
\end_layout

\begin_layout Plain Layout

												} 		
\end_layout

\begin_layout Plain Layout

										} 		// input has still till <20> (excluding <20>) 		
\end_layout

\begin_layout Plain Layout

								rem_spaces(input); 		
\end_layout

\begin_layout Plain Layout

								strcpy(name,input); //we have name of comp now 	
\end_layout

\begin_layout Plain Layout

						} 	
\end_layout

\begin_layout Plain Layout

						pclose(pipe); 	
\end_layout

\begin_layout Plain Layout

						if(success==1) 		
\end_layout

\begin_layout Plain Layout

						writename(name,ip); 	
\end_layout

\begin_layout Plain Layout

						return(success); }
\end_layout

\begin_layout Plain Layout

void writeshares(struct listnode *sharelist,char *ip) { 	/* 	 * if comp
 is connected ...
  	 * then shares are writtern in ../files/shares/ip 	 * and tree of shares
 is built in next stage 	 * this stage also deletes the tree files which
 correspond to ...
 	 * shared folders which are no longer shared 	 */ 
\end_layout

\begin_layout Plain Layout

	FILE *fp; 	DIR *dp; 	struct dirent *dinfo; 	char filename[256],*fileip,*filesha
re,command[256]; 	struct listnode *p,*filelist;
\end_layout

\begin_layout Plain Layout

	filelist=p=NULL; 
\end_layout

\begin_layout Plain Layout

	strcpy(filename,"../files/shares/"); 	strcat(filename,ip); 	fp=fopen(filename,"w"
); 	// write list of shares ...
 	if(fp==NULL) 	{ 		fprintf(stderr,"Error Can't write shares for %s",ip);
 		perror(""); 		return; 	} 	// null list implies empty shares file 	//
 as file was opened with MODE "w" 	for(p=sharelist;p!=NULL;p=p->next) 		fprintf(
fp,"%s
\backslash
n",p->key); 	fclose(fp); 	dp=opendir("../files/tree"); 	if(dp==NULL) 		perror("Err
or Can't open dir (sync share list) "); 	while(dinfo=readdir(dp)) 	{ 		if(strcmp
(dinfo->d_name,".")==0 				|| strcmp(dinfo->d_name,"..")==0) 			continue; //
 skip these two files 		filelist=addtolist(filelist,dinfo->d_name,""); 	}
 	closedir(dp); 	for(p=filelist;p!=NULL;p=p->next) 	{ 		strcpy(filename,p->key);
 		// filename has format ip_address%sharename 		fileip=(char *)strtok(filename,
"%
\backslash
n"); 		if(strcmp(fileip,ip)!=0) continue; 		fileshare=(char *)strtok(NULL,"%
\backslash
n"); 		if((char *)searchlist(sharelist,fileshare)==NULL) 		{ 			printf("Removing
 %s : no longer shared
\backslash
n",p->key); 			strcpy(command,"rm 
\backslash
""); 			strcat(command,"../files/tree/"); 			strcat(command,p->key); 			strcat(com
mand,"
\backslash
""); 			system(command); 		} 	} 	freelist(filelist); // regain memory }
\end_layout

\begin_layout Plain Layout

struct listnode *findshares(char *name,char *ip) { 	struct listnode *sharelist=N
ULL; 	char command[256],input[256]; 	FILE *pipe; 	int success=0; 
\end_layout

\begin_layout Plain Layout

	strcpy(command,"smbclient -L 
\backslash
""); 	strcat(command,name); 	strcat(command,"
\backslash
" -I "); 	strcat(command,ip); 	strcat(command," -N");
\end_layout

\begin_layout Plain Layout

	pipe=popen(command,"r"); // command used as junk space below 	while(fgets(input
,256,pipe)!=NULL) 	{ 		// add some smart error parsing here 		if((char *)strstr(
input,"Domain=")!=NULL 				&& (char *)strstr(input,"OS=")!=NULL 				&& (char
 *)strstr(input,"Server=")!=NULL) 			success=1; 		if((char *)strstr(input,"Share
name")!=NULL 				&& (char *)strstr(input,"Type")!=NULL 				&& (char *)strstr(inp
ut,"Comment")!=NULL) 			success=1; 		strcpy(command,ip); 		strcat(command,":139"
); 		if((char *)strstr(input,command)!=NULL 				&& (char *)strstr(input,"(Connec
tion refused")!=NULL) 			success=1; // so connection was refused 		if((char
 *)strstr(input,"Called name not present")!=NULL) 		{ 			// this happens
 when name of the system has changed 			strcpy(command,"rm ../files/names/");
 			strcat(command,ip); 			system(command); 			// name of comp removed 
 			// next time i will find the new name 			// not doing it this time to
 avoidm race condition 			success=1; 		} 		if((char *)strstr(input,"Disk")==NULL
) continue; 		//-> assumption that smbclient output will have Disk at 16th
 char 		//-> using smbclient version 2.2.1a 		if(input[16]!='D' || input[17]!='i'
  				|| input[18]!='s' || input[19]!='k') 		{ 			fprintf(stderr,"Error
 : 
\backslash
"Disk
\backslash
" in %s
\backslash
n",input); 			continue; 		} 		input[16]='
\backslash
0'; //+++ a very chutia assumption 		rem_spaces(input); 		sharelist=addtolist(sh
arelist,input,""); 	} 	pclose(pipe); 	//if(success==1) 		writeshares(sharelist,i
p); 	return(sharelist); }
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]) { 	FILE *fp; 	char ip[20],filename[256],name[20
],sharename[256]; 	char pidjunk[20],command[256]; 	struct stat filebuf;
 	int ret,i; 	time_t ctime; 	struct listnode *sharelist=NULL; 	struct listnode
 *p=NULL;
\end_layout

\begin_layout Plain Layout

	if(argc!=3) 	{ 		fprintf(stderr,"Usage : driver ip_address sleep_time(min)
\backslash
n"); 		exit(1); 	} 	ret=0; 	ret=(int)strtol(argv[2],NULL,0); 	if(ret>0)
 		sleep(ret*60); 	// check if host is up 	strcpy(ip,argv[1]); 	strcpy(command,"
ping -c 1 -w 2 -n "); 	strcat(command,ip); 	strcat(command," 2> /dev/null");
 	fp=popen(command,"r"); 	while(fgets(filename,256,fp)!=NULL) 	{ 		if((char
 *)strstr(filename,"icmp_seq")!=NULL) 			ret=1; 	} 	if(ret==0) exit(0);
 // host is down
\end_layout

\begin_layout Plain Layout

	if(strcmp(ip,"10.136.1.211")==0) exit(1); 	time(&ctime); // current time 
\end_layout

\begin_layout Plain Layout

	strcpy(filename,"../files/names/"); 	strcat(filename,ip); 	ret=stat(filename,&fil
ebuf); 	strcpy(name,""); 	if((ret>=0) && (ctime - filebuf.st_mtime < 3600*12)
  			&& (strcmp(argv[2],"-1")!=0)){  		// file for name is there and is
 not so old 		fp=fopen(filename,"r"); 		if(fp==NULL) 		{ 			perror("Error
 in reading old name "); 			exit(0); 		} 		fgets(name,20,fp); 		rem_spaces(name)
; 		fclose(fp); 	} 	else 	{ 		printf("Finding name of %s
\backslash
n",ip); 		fflush(stdout); 		findname(name,ip); // returns 1 on success 	}
\end_layout

\begin_layout Plain Layout

	if(strcmp(name,"")==0)  	{ 		writeshares(NULL,ip); 		exit(1); // comp has
 no name 	} 
\end_layout

\begin_layout Plain Layout

	// now that we have got name of comp 	// let's find the shares of that
 comp 	strcpy(filename,"../files/shares/"); 	strcat(filename,ip); 	ret=stat(filena
me,&filebuf); 	time(&ctime); 	if((ret>=0) && (ctime-filebuf.st_mtime < 3600*4)
  			&& (strcmp(argv[2],"-1")!=0)) 	{ 		// we have info about shares 		fp=fopen(
filename,"r"); 		if(fp==NULL) 		{ 			fprintf(stderr,"Error in reading old
 shares of %s",ip); 			perror(""); 			exit(1); 		} 		while(fgets(sharename,256,f
p)!=NULL) 		{ 			rem_spaces(sharename); 			if(strcmp(sharename,"")==0) continue;
 			// now sharename has no traling spaces 			sharelist=addtolist(sharelist,shar
ename,""); 		} 		fclose(fp); 	} 	else 	{ 		printf("Finding share list of
 %s (%s) 
\backslash
n",ip,name); 		sharelist=findshares(name,ip); 	} 	if(sharelist==NULL) exit(0);
 // sharelist is NULL
\end_layout

\begin_layout Plain Layout

	// cool ...
 we have the share list ..
 time to build tree.
 	for(p=sharelist;p!=NULL;p=p->next) 	{ 		strcpy(filename,"../files/tree/");
 		strcat(filename,ip); 		strcat(filename,"%"); 		strcat(filename,p->key);
 		ret=stat(filename,&filebuf); 		time(&ctime); 		if((ret>=0) && (ctime-filebuf.s
t_mtime < 3600*6)  				&& (strcmp(argv[2],"-1")!=0)) 			continue; // skip
 this share  		printf("Attempt to mount %s (%s) -> %s
\backslash
n",ip,name,p->key); 		sprintf(pidjunk,"%d",(int)getpid()); 		ret=buildtree(p->ke
y,name,ip,pidjunk); 		if(ret==0) 			continue; // comp was not connected
 		strcpy(filename,"../files/tmp/tree_"); 		strcat(filename,pidjunk); 	
\end_layout

\begin_layout Plain Layout

		strcpy(command,"mv "); 		strcat(command,filename); // tree file 		strcat(comma
nd," 
\backslash
""); 		strcpy(filename,"../files/tree/"); 		strcat(filename,ip); 		strcat(filename
,"%"); 		strcat(filename,p->key); 		strcat(command,filename); 		strcat(command,"
\backslash
""); 		system(command); 	}	 	freelist(sharelist); } 
\end_layout

\end_inset


\end_layout

\begin_layout Part
Puyo Puyo ( A 2D Game )
\end_layout

\begin_layout Standard
This was the problem asked in my Gameloft Interview in the preliminary round.
 It was worked on by Rahul Agrawal.
 I chose PHP later in life and wasn't comfortable with Java.
 (2007)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import java.applet.*; import java.awt.*; import java.awt.image.*; import java.awt.event.*;
 //import java.net.*;
\end_layout

\begin_layout Plain Layout

public class Puyopuyo extends Applet implements Runnable, KeyListener{ //drawing
 vars BufferedImage bufferdImg; Graphics2D bufferdImgSurface; Thread gameThread;
 public int scrWD,scrHT;	//screen wd nd ht Image eyecon[]=new Image[6];		//image
 of icon 0=blank,1=yellow,2=green,3blue,4=red,5=gray public int bordPX,bordPY;
 public int bordTop=50,bordLft=10;
\end_layout

\begin_layout Plain Layout

//board vars public int bordXct=6,bordYct=12;			//board dimensions	//use
 only even numbers for bordXct....
 public int bordct=bordXct*bordYct;			//number of icons public int bordX[]=new
 int[bordct];			//bord x			 public int bordY[]=new int[bordct];			//bord
 y public int bordpxlX[]=new int[bordct];		//xpxel position  public int
 bordpxlY[]=new int[bordct];		//ypixel position public int bordicon[]=new
 int[bordct];		//color of icon 0=blank,1=yellow,2=green,3blue,4=red,5=gray
 public int bordLnk[]=new int[bordct];		//link number	*determines their
 linkage to surroounding icons public boolean bordpvt[]=new boolean[bordct];	//i
s capsule pivot	 public boolean bordcapsule[]=new boolean[bordct];	//is
 capsule public boolean bordfxd[]=new boolean[bordct];		//is fixed to bord?
 public int Lnkct;									//link count
\end_layout

\begin_layout Plain Layout

public int iconz=32;		//icon size public boolean canCtrlCaps;	//can you
 control the capsule? public int capsDxn;			//capsule direction public boolean
 isderCaps; public int cap1,cap2;
\end_layout

\begin_layout Plain Layout

/* capsDxn--- [pvt][odr]	=	3
\end_layout

\begin_layout Plain Layout

[odr][pvt]	=	1
\end_layout

\begin_layout Plain Layout

[pvt] [odr]		=	4
\end_layout

\begin_layout Plain Layout

[odr] [pvt]		=	2
\end_layout

\begin_layout Plain Layout

* the pvt being the Front of the capsule
\end_layout

\begin_layout Plain Layout

1	=	going left 2	=	down 3	=	ryt 4	=	up
\end_layout

\begin_layout Plain Layout

the number corresponds to these : and the number inside the plane corresponds
 to the  index of array
\end_layout

\begin_layout Plain Layout

			12	|	66	67	68	69	70	71 			11	|	60	61	62	63	64	65 			10	|	54	55	56	57	58	59
 			9	|	48	49	50	51	52	53 			8	|	42	43	44	45	46	47 			7	|	36	37	38	39	40	41
 	bord Y	6	|	30	31	32	33	34	35 			5	|	24	25	26	27	28	29 			4	|	18	19	20	21	22	23
 			3	|	12	13	14	15	16	17 			2	|	6	7	8	9	10	11 			1	|  _0_ _1_ _2_ _3_ _4_
 _5_ 					1	2	3	4	5	6 						bord X			 		
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

//game timing vars public long dwnTymHoldr;		//holder for the down tym public
 long dwnTym;		//lenght of delay for icons to fall public long dwnTymStrt;				//
start of down time public long movedelay;				//delay time public long movedelayS
trt;			//start of move(not down) delay public boolean ismovedelay;			//are
 you delaying the move? public boolean freeze; public long freezeStrt,freezeTym;
\end_layout

\begin_layout Plain Layout

//game switches boolean isOver;		//game over boolean isAuto;		//the game
 moves by itself boolean isStart;	//start to play? boolean isPlay;		//r
 we playing?
\end_layout

\begin_layout Plain Layout

//move swithces boolean toLft;	//move capsule to left? boolean toRyt;	//move
 capsule to ryt? boolean rot8L;	//rot8 ccwise? boolean rot8R;	//rot8 cwise?
 boolean toDwn;	//move icons/capsule down? boolean toSwc;	//switch capsule
 places?
\end_layout

\begin_layout Plain Layout

//score vars public long hiscore,score; public int lvl; public long lnkCtr;
\end_layout

\begin_layout Plain Layout

//sleep vars		i just copied this part from a tutorial but i know (barely)
 how it works //					it's self explanatory :) long tick_start,	// Frame
 start time tick_end,			// End frame time tick_duration,		// Time taken
 to display the frame sleep_duration;		// How long to sleep for static final
 int MIN_SLEEP_TIME = 1,	// Min time to sleep MAX_FPS = 50,							// Max
 frame rate.
 MAX_MS_PER_FRAME = 1000 / MAX_FPS;		// MS per frame
\end_layout

\begin_layout Plain Layout

//xtravars public int gg;
\end_layout

\begin_layout Plain Layout

public void start(){		//i just copied this part from a tutorial :) 	Thread
 gameThread = new Thread(this); 	gameThread.start(); 	}
\end_layout

\begin_layout Plain Layout

public void init(){	//i also copid this :) this is where initialization
 takes place 	int i; 	if (bordXct<6)			// min size of vordxct =6 		bordXct=6;
 	else if (bordXct%2!=0)	//or odd number 		bordXct=bordXct+1; 	if (bordYct<12)		
	//min size of bordyct =12 		bordYct=12; 	initBoard();	//initialize the
 boards 	bufferdImg = (BufferedImage)createImage(scrWD,scrHT); 	bufferdImgSurfac
e = bufferdImg.createGraphics(); 	isOver=false;	//initialize values...
 	toLft=false; 	toRyt=false; 	rot8L=false; 	rot8R=false; 	toDwn=false; 	toSwc=fa
lse; 	isPlay=false; 	isStart=true; 	isderCaps=false; 	hiscore=0; 	for (i=1;i<=5;
i++)		// initialize the images 		eyecon[i]=getImage(getCodeBase(), "img/"+i+".png
"); 	addKeyListener(this); 	}
\end_layout

\begin_layout Plain Layout

public void run(){ 	while(true){		// Starts the loop 		tick_start = System.curren
tTimeMillis(); 		if (ismovedelay && System.currentTimeMillis()>movedelayStrt+move
delay)	//if current time > delaystrt and delay 			ismovedelay=false;	//u
 can now make a move :) 		if (System.currentTimeMillis()>dwnTym+dwnTymStrt
 && isPlay) //if current time > dwntymstart + downtym 			toDwn=true;	//move
 icons down 		if (freeze) 			if (System.currentTimeMillis()>freezeTym+freezeStrt)
{ 				dwnTymStrt=System.currentTimeMillis(); 				freeze=false;				 				}
 		repaint(); // Redraw the screen 		tick_end = System.currentTimeMillis();
 		tick_duration = tick_end - tick_start; 		sleep_duration = MAX_MS_PER_FRAME
 - tick_duration; 		if (sleep_duration < MIN_SLEEP_TIME) 			sleep_duration
 = MIN_SLEEP_TIME; 		try { 			Thread.sleep(sleep_duration); 			} 		catch(Interrup
tedException e){} 		} 	}
\end_layout

\begin_layout Plain Layout

public void paint(Graphics g){ 	update(g); 	}
\end_layout

\begin_layout Plain Layout

public void update(Graphics g){	//updates the screen 	if (freeze)	//if is
 over, no mre...
 		return; 	Graphics2D g2 = (Graphics2D)g; 	int i; 	boolean fin=false,tobreak=fa
lse; 	bufferdImgSurface.clearRect(0, 0, scrWD, scrHT); 	bufferdImgSurface.setBackg
round(Color.black); 	drwBorder(bufferdImgSurface);	//draws the lines 	drwscores(b
ufferdImgSurface); 	if (isStart){ 		bufferdImgSurface.setColor(Color.yellow);
 		bufferdImgSurface.drawString("Hit Enter to Start..!",(scrWD/2)-50,scrHT/2);
 		} 	if (isOver){ 		bufferdImgSurface.setColor(Color.yellow); 		bufferdImgSurface.
drawString("Game Over..!",(scrWD/2)-35,bordTop-10);	 		//drwCap(bufferdImgSurface)
; 		drwImg(bufferdImgSurface);	//drwas the entire bord 		} 
\end_layout

\begin_layout Plain Layout

	if (isPlay){ 		if (isAuto){	//the game automatically controls the game
 			dwnTym=50;	//makes down tym a bit faster 			if(chkFloat()){	//there
 are floating icons 				if(toDwn){	//can move icons down? 					toDwn=false;
 					moveallDwn();	//move all floating icons down 					dwnTymStrt=System.current
TimeMillis();	//set dwn tym start 					} 				} 			else{			//no floating
 				lnkBord();	//link the boed 				if (Lnkct==0){	//there are no links
 					isAuto=false;	//return to player control 					toDwn=false;	 					dwnTym=dw
nTymHoldr;	//dwntym is reset to initialized value 					dwnTymStrt=System.currentT
imeMillis();	//set dwntym start 					} 				else{		//there is a link  					for
 (i=1;i<=Lnkct;i++){	//loop all links check every link 						if (chkbordlnk(i)){
	// if there is something to break 							tobreak=true;	//there is 							break;
 							} 						} 					if (!tobreak){		//no links to breaks 						isAuto=false;	
//return to player control (same as when lnkCt==0 						toDwn=false; 						dwnTy
m=dwnTymHoldr; 						dwnTymStrt=System.currentTimeMillis();					 						}
 					else{	//break those links :) and make the others float 						for (i=1;i<=L
nkct;i++){	//loop all link 							if (chkbordlnk(i)){	//this link number
 rulzzz 								score=score+getscore(i);	//add to score 								breaklnk(i);	//b
reak this link 								}	 							} 						lnkCtr++; 						makeFloat();	//makes
 the PROBABLE icons float(unfixed to bord) 						chkstage(); 						toDwn=false;
 						freeze=true; 						freezeStrt=System.currentTimeMillis(); 						freezeTym=
250; 						} 					} 				} 			} 		else{	//player control 			if (!isderCaps)
 				newCaps(); 			if (!chkFloat()){	//if there are no floating 				if (!transCa
ps()){	//create new capsule, if false end of game 					ismovedelay=true;	
 					toDwn=false; 					fin=true; 					} 				else	//true, u can control
 the capsule 					canCtrlCaps=true; 				} 			if(!ismovedelay){	//is your
 move delayed? 				if (toLft){		//move caps to left? 					toLft=false; 					move
CLft();	//move it left 					} 				else if(toRyt){	//to ryt? 					toRyt=false;
 					moveCRyt();	//go ryt 					} 				else if(toSwc){	//switch? 					toSwc=false
; 					switchCaps();	//switch places 					} 				else if(rot8R){		//rot8
 ryt? 					rot8R=false; 					moverot8R();	//then go on 					} 				else if(rot8L)
{		//or left 					rot8L=false; 					moverot8L();	//my pleasure 					} 				}
 			if(toDwn){	//move the capsule down? 				toDwn=false; 				movecapDwn();	//mov
e capsule down 				dwnTymStrt=System.currentTimeMillis();	 				} 			} 			drwCap(b
ufferdImgSurface); 			drwImg(bufferdImgSurface);	//drwas the entire bord
 		} 	
\end_layout

\begin_layout Plain Layout

	if (fin){	//game over? 		//for (i=0;i<bordct;i++)	//loop all icon 		//	if
 (bordicon[i]!=0)	//if not blank 		//		bordicon[i]=5;	//make it gray 		isOver=tr
ue;	//is over...
 :( 		isPlay=false; 		} 	bufferdImgSurface.setColor(Color.yellow); 	bufferdImgSurf
ace.drawString("Gawang Pinoy...!",5,scrHT-15); 	bufferdImgSurface.drawString("Gawa
 ni Jecson Eslabra...!",5,scrHT-5); 	//xtraxtra 	//bufferdImgSurface.drawString("pvt
 bx,by = "+String.valueOf(bordX[getIdxpvt()])+","+String.valueOf(bordY[getIdxpvt()
]),10,20); 	//bufferdImgSurface.drawString("idxpvt "+String.valueOf(getIdxpvt()),
 10,30); 	//bufferdImgSurface.drawString("odr bx,by = "+String.valueOf(bordX[getId
xodr()])+","+String.valueOf(bordY[getIdxodr()]),10,20); 	//bufferdImgSurface.drawS
tring("idxodr "+String.valueOf(getIdxodr()), 10,30); 	//bufferdImgSurface.drawStri
ng(String.valueOf(System.currentTimeMillis()), 10,scrHT-30); 	//bufferdImgSurface.d
rawString(String.valueOf(dwnTymStrt), 10,scrHT-40); 	g2.drawImage(bufferdImg,
 0, 0, this); 	}
\end_layout

\begin_layout Plain Layout

public void initBoard(){	//init the bord 	int i; 	canCtrlCaps=false; 	capsDxn=0;
 	bordPX=iconz*bordXct; 	bordPY=iconz*bordYct; 	scrWD=(bordLft*2)+bordPX;
 	scrHT=bordTop+bordPY+bordLft+25; 	int x=1,y=1; 	for (i=0;i<bordct;i++){	//loop
 all bordicons 		bordX[i]=x;	//set bordx 		bordY[i]=y;	//set bordy 		bordpxlX[i]
=((x-1)*iconz)+bordLft;	//set x pixel 		bordpxlY[i]=(bordTop+bordPY)-(y*iconz);	
	//set y pixel 		bordicon[i]=0;					//icon=blank 		bordpvt[i]=false; 		bordcapsu
le[i]=false; 		bordfxd[i]=false;	//unfix all icons 		x++;	//add x 		if (x>bordXc
t){	//x>width of bord? 			x=1;	//reset to 1 			y++;	//add y 			} 		} 	clrLnk();	
//clear all loinks 	}
\end_layout

\begin_layout Plain Layout

public void initGame(){ 	initBoard(); 	score=0; 	lvl=1; 	lnkCtr=0; 	dwnTymHoldr=
2500; 	dwnTym=dwnTymHoldr; 	ismovedelay=false; 	dwnTymStrt=System.currentTimeMill
is();	//set dwn tym start 	}
\end_layout

\begin_layout Plain Layout

public void chkstage(){ 	if (lnkCtr>=5){ 		lvl++; 		if (dwnTymHoldr>500)
 			dwnTymHoldr=dwnTymHoldr-500; 		else if (dwnTymHoldr>100) 			dwnTymHoldr=dwnT
ymHoldr-100; 		dwnTym=dwnTymHoldr; 		lnkCtr=0; 		} 	} 
\end_layout

\begin_layout Plain Layout

public int getscore(int ini){ 	int i; 	int ctr=0; 	for (i=0;i<bordct;i++){
 		if (bordLnk[i]==ini)	//if linknumber of icon==sought-after linknumber
 			ctr++; 		} 	return 200+((ctr-4)*100); 	} 
\end_layout

\begin_layout Plain Layout

public void drwscores(Graphics2D sorpes){ 	sorpes.setColor(Color.white); 	if
 (score>hiscore && score>5000) 		hiscore=score; 	sorpes.drawString("HI-Score
  : " + hiscore,10,10); 	sorpes.drawString("Score       : " + score,10,20);
 	if (lvl!=0) 		sorpes.drawString("Lvl.
  : " + lvl,10,bordTop-7); 	}
\end_layout

\begin_layout Plain Layout

public void drwCap(Graphics2D sorpes){ 	sorpes.drawImage(eyecon[cap1],(scrWD/2)+i
conz,bordTop-iconz-5,this); 	sorpes.drawImage(eyecon[cap2],(scrWD/2)+(iconz*2),bo
rdTop-iconz-5,this); 	} 
\end_layout

\begin_layout Plain Layout

public void drwImg(Graphics2D sorpes){	//drwas the icons 	int i; 	int kulay;
 	for(i=0;i<bordct;i++){	//loop all icons 		kulay=bordicon[i];	//get icon
 color 		if (kulay!=0){	//if not blank 			sorpes.drawImage(eyecon[kulay],bordpxlX
[i],bordpxlY[i],this); //			if (kulay==1) //				sorpes.setColor(Color.yellow);
 //			else if (kulay==2) //				sorpes.setColor(Color.green); //			else if
 (kulay==3) //				sorpes.setColor(Color.blue); //			else if (kulay==4) //				sorpe
s.setColor(Color.red); //			else //				sorpes.setColor(Color.gray); 			//set
 according to color //			sorpes.fillOval(bordpxlX[i],bordpxlY[i],iconz,iconz);	//
dra bid circle //			sorpes.setColor(Color.black); //			sorpes.fillOval(bordpxlX[i]+
7,bordpxlY[i]+8,6,7);	//left eye //			sorpes.fillOval(bordpxlX[i]+18,bordpxlY[i]+
8,6,7);	//ryt eye //			sorpes.fillOval(bordpxlX[i]+5,bordpxlY[i]+18,20,7);	//smil
e :) 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void moveCLft(){ 	int c1,c2,cx1,cy1,cx2,cy2; 	c1=getIdxpvt();	//get
 the index if the PVT of capsule 	c2=getIdxodr();	//get the index of the
 ODR of capsule 	cx1=bordX[c1];	//self explanatory 	cy1=bordY[c1]; 	cx2=bordX[c2
]; 	cy2=bordY[c2];	 	if (cx2==1 || cx1==1)	//if any icon on the left border
 of bord ucant move enimore 		return; 	if (cx1>cx2 && !bordfxd[c2-1]){		//caps=h
orizontal ..
 the PVT is on the ryt && nothing on left 		bordicon[c2-1]=bordicon[c2];	//copy
 ODR icon to left 		bordicon[c2]=bordicon[c1];		//copy PVT icon to left
 		bordicon[c1]=0;					//make current PVT icon blank 		bordpvt[c2]=true;				//ma
kes ODR the PVT 		bordcapsule[c2-1]=true;			//makes left of ODR capsule
 		bordpvt[c1]=false;				//unpivot the PVT 		bordcapsule[c1]=false;			//uncapsul
e the PVT 		} 	else if(cx1<cx2 && !bordfxd[c1-1]){	//caps=horizontal ..
 the pvot is on the lft && nothing on left 		bordicon[c1-1]=bordicon[c1];	//same
 as above :) 		bordicon[c1]=bordicon[c2]; 		bordicon[c2]=0; 		bordpvt[c1-1]=true
; 		bordcapsule[c1-1]=true; 		bordpvt[c1]=false; 		bordcapsule[c2]=false;
 		} 	else if (!bordfxd[c1-1] && !bordfxd[c2-1]){	//caps=vertical ..
 left of both capsule is unfxd 		bordicon[c1-1]=bordicon[c1];	//same also
 as above:) 		bordicon[c2-1]=bordicon[c2]; 		bordicon[c2]=0; 		bordicon[c1]=0;
 		bordcapsule[c1-1]=true; 		bordcapsule[c2-1]=true; 		bordcapsule[c1]=false;
 		bordcapsule[c2]=false; 		bordpvt[c1-1]=true; 		bordpvt[c1]=false; 		}
 	}	
\end_layout

\begin_layout Plain Layout

/* the same concept of moving applies when going ryt */
\end_layout

\begin_layout Plain Layout

public void moveCRyt(){ 	int c1,c2,cx1,cy1,cx2,cy2; 	c1=getIdxpvt(); 	c2=getIdxo
dr(); 	cx1=bordX[c1]; 	cy1=bordY[c1]; 	cx2=bordX[c2]; 	cy2=bordY[c2];	 	if
 (cx1==bordXct || cx2==bordXct) 		return; 	if (cx1>cx2 && !bordfxd[c1+1]){		//ca
ps=horizontal ..
 the pvot is on the ryt && nothing on ryt 		bordicon[c1+1]=bordicon[c1];
 		bordicon[c1]=bordicon[c2]; 		bordicon[c2]=0; 		bordpvt[c1+1]=true; 		bordcaps
ule[c1+1]=true; 		bordpvt[c1]=false; 		bordcapsule[c2]=false; 		} 	else
 if(cx1<cx2 && !bordfxd[c2+1]){	//caps=horizontal ..
 the pvot is on the lft && nothing on ryt 		bordicon[c2+1]=bordicon[c2];
 		bordicon[c2]=bordicon[c1]; 		bordicon[c1]=0; 		bordpvt[c2]=true; 		bordcapsul
e[c2+1]=true; 		bordpvt[c1]=false; 		bordcapsule[c1]=false; 		} 	else if
 (!bordfxd[c1+1] && !bordfxd[c2+1]){	//caps=vertical ..
 and right of bot capsule unfxd 		bordicon[c1+1]=bordicon[c1]; 		bordicon[c2+1]=
bordicon[c2]; 		bordicon[c2]=0; 		bordicon[c1]=0; 		bordcapsule[c1+1]=true;
 		bordcapsule[c2+1]=true; 		bordcapsule[c1]=false; 		bordcapsule[c2]=false;
 		bordpvt[c1+1]=true; 		bordpvt[c1]=false; 		} 	}
\end_layout

\begin_layout Plain Layout

public void switchCaps(){	//switch capsule color 	int c1,c2,cx1,cy1,cx2,cy2,tmp;
 	c1=getIdxpvt();	//already discussed 	c2=getIdxodr(); 	cx1=bordX[c1]; 	cy1=bord
Y[c1]; 	cx2=bordX[c2]; 	cy2=bordY[c2]; 	tmp=bordicon[c1];	//hold PVT icon
 color 	bordicon[c1]=bordicon[c2];	//Copy ODR icon color to PVT 	bordicon[c2]=tm
p;	//copy held to ODR 	}
\end_layout

\begin_layout Plain Layout

public void moverot8R(){	//rotate the capsule clockwise 	int c1,c2,cx1,cy1;
 	c1=getIdxpvt();	//:) 	c2=getIdxodr(); 	cx1=bordX[c1]; 	cy1=bordY[c1];
\end_layout

\begin_layout Plain Layout

	if (capsDxn==1){	//ryt going down 		if (cy1!=bordYct){	//on topmost row?
 			bordicon[c1+bordXct]=bordicon[c2];	//copy ODR to target ODR 			bordcapsule[c
1+bordXct]=true;		//make it capsule 			bordicon[c2]=0;						//un-icon currect
 ODR 			bordcapsule[c2]=false;				//un-capsule current ODR 			capsDxn=2;							/
/change dxn 			} 		} 	else if (capsDxn==2){	//down going left 		if (cx1!=bordXct
 && !bordfxd[c1+1]){	//if not on ryt border of bord && tgt ODR is not fxd
 			bordicon[c1+1]=bordicon[c2]; 			bordcapsule[c1+1]=true; 			bordicon[c2]=0;
 			bordcapsule[c2]=false; 			capsDxn=3; 			} 		} 	else if (capsDxn==3){	//left
 going up 		if (!chkUnder(cx1,cy1)){	//if nothing under PVT 			bordicon[c1-bordX
ct]=bordicon[c2]; 			bordcapsule[c1-bordXct]=true; 			bordicon[c2]=0; 			bordcap
sule[c2]=false; 			capsDxn=4; 			} 		} 	else if (capsDxn==4){	//up gpoing
 left 		if (cx1!=1 && !bordfxd[c1-1]){	//if not on left border of bord &&
 tgt ODR unfxd 			bordicon[c1-1]=bordicon[c2]; 			bordcapsule[c1-1]=true;
 			bordicon[c2]=0; 			bordcapsule[c2]=false; 			capsDxn=1; 			} 		} 	}
\end_layout

\begin_layout Plain Layout

/* same concept of rotating as moverot8R */ public void moverot8L(){	//rotate
 counter clockwise 	int c1,c2,cx1,cy1; 	c1=getIdxpvt(); 	c2=getIdxodr();
 	cx1=bordX[c1]; 	cy1=bordY[c1];
\end_layout

\begin_layout Plain Layout

	if (capsDxn==3){	//left going down 		if (cy1!=bordYct){ 			bordicon[c1+bordXct]
=bordicon[c2]; 			bordcapsule[c1+bordXct]=true; 			bordicon[c2]=0; 			bordcapsul
e[c2]=false; 			capsDxn=2; 			} 		} 	else if (capsDxn==4){	//up going left
 		if (cx1!=bordXct && !bordfxd[c1+1]){ 			bordicon[c1+1]=bordicon[c2];
 			bordcapsule[c1+1]=true; 			bordicon[c2]=0; 			bordcapsule[c2]=false;
 			capsDxn=3; 			} 		} 	else if (capsDxn==1){	//ryt going up 		if (!chkUnder(cx
1,cy1)){ 			bordicon[c1-bordXct]=bordicon[c2]; 			bordcapsule[c1-bordXct]=true;
 			bordicon[c2]=0; 			bordcapsule[c2]=false; 			capsDxn=4; 			} 		} 	else
 if (capsDxn==2){	//down going ryt 		if (cx1!=1 && !bordfxd[c1-1]){ 			bordicon[
c1-1]=bordicon[c2]; 			bordcapsule[c1-1]=true; 			bordicon[c2]=0; 			bordcapsule
[c2]=false; 			capsDxn=1; 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void movecapDwn(){	//movecapsule down 	if (!canCtrlCaps) 		return;
 	int c1,c2,cx1,cy1,cx2,cy2,tmp; 	boolean c1u,c2u;	//checkunder for PVT,ODR
 	c1=getIdxpvt();	//:) 	c2=getIdxodr(); 	cx1=bordX[c1]; 	cy1=bordY[c1];
 	cx2=bordX[c2]; 	cy2=bordY[c2]; 	if (capsDxn%2==0){	//verticalcapsulse
 		if (cy2<cy1){	//ODR under PVT 			if (chkUnder(cx2,cy2)){	//there's something
 beneath mek it fxd 				bordfxd[c2]=true;	//ODR fxd 				bordfxd[c1]=true;	//PVT
 fxd 				bordpvt[c1]=false;	//un-pvt 				bordcapsule[c1]=false;	//uncaps
 PVT 				bordcapsule[c2]=false;	//uncaps ODR 				//lnkBord(); 				canCtrlCaps=fa
lse;	//cant control capsule 				isAuto=true;	//set to automatic 				} 			else{	/
/nothing just move down 				moveiconDwn(cx2,cy2);	//move ODR down 				moveiconDw
n(cx1,cy1);	//move PVT down 				bordpvt[c2]=true;		//make current ODR PVT
 				bordpvt[c1]=false;		//un-pvot PVT 				bordcapsule[c2-bordXct]=true;	//make
  				bordcapsule[c1]=false; 				} 			} 		else{	//PVT under ODR 			if (chkUnder(
cx1,cy1)){	//there's something beneath make it fixd 				bordfxd[c2]=true;
 				bordfxd[c1]=true; 				bordpvt[c1]=false; 				bordcapsule[c1]=false;
 				bordcapsule[c2]=false; 				//lnkBord(); 				canCtrlCaps=false; 				isAuto=t
rue; 				} 			else{	//nothing just move down 				moveiconDwn(cx1,cy1); 				movei
conDwn(cx2,cy2); 				bordpvt[c1-bordXct]=true; 				bordpvt[c1]=false; 				bordca
psule[c1-bordXct]=true; 				bordcapsule[c2]=false; 				} 			} 		} 	else{		//hori
zontal capsule 		c1u=chkUnder(cx1,cy1); 		c2u=chkUnder(cx2,cy2); 		if (c1u
 || c2u){	//if eni under of the caps is fixed 			if (c1u)	//if under PVT
 				bordfxd[c1]=true;	//make it fixed 			if (c2u) 				bordfxd[c2]=true;
 			bordpvt[c1]=false; 			bordcapsule[c1]=false; 			bordcapsule[c2]=false;
 			//lnkBord(); 			canCtrlCaps=false; 			isAuto=true; 			} 		else{	//nothing
 just move them down 			moveiconDwn(cx1,cy1); 			moveiconDwn(cx2,cy2); 			bordca
psule[c1]=false; 			bordcapsule[c2]=false; 			bordcapsule[c1-bordXct]=true;
 			bordcapsule[c2-bordXct]=true; 			bordpvt[c1]=false; 			bordpvt[c1-bordXct]=t
rue; 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void clrLnk(){	//removes all link 	int i; 	Lnkct=0; 	for (i=0;i<bordct;i+
+) 		bordLnk[i]=0;	//set link number to 0 	}
\end_layout

\begin_layout Plain Layout

public boolean chkbordlnk(int inLnknum){	//check if inLnknum is linked >4
 ..
 inLnknum is a linknumber 	int i; 	int ctr=0; 	for (i=0;i<bordct;i++){ 		if
 (bordLnk[i]==inLnknum)	//if linknumber of icon==sought-after linknumber
 			ctr++; 		if (ctr==4)	//:) 			return true;	//this is a linknumber with
 >=4 icons linked 		} 	return false;	//nope 	}
\end_layout

\begin_layout Plain Layout

public void breaklnk(int inLnk){	//breaks the link of the linknumber used
 in conjuction with chkbordLnk 	int i; 	for (i=0;i<bordct;i++){ 		if (bordLnk[i]
==inLnk){	//same link num? 			bordicon[i]=0;		//make it blank 			bordfxd[i]=fals
e;	//make it unfxd 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void lnkBord(){	//link the bord 	clrLnk();	//clear links 	int x,y,idx,idx
tgt; 	for (x=1;x<=bordXct;x++){		//loop to ryt 		for (y=1;y<=bordYct;y++){	//loo
p to up 			idx=getbordIdx(x,y);	//get index of the current (x,y) 			if (bordfxd[
idx]){	//if this is fixd 				if (y!=bordYct){		//not yet on top u can link
 upwards 					idxtgt=getbordIdx(x,y+1);	//get idx of target icon 					if
 (bordicon[idxtgt]==bordicon[idx] && bordicon[idx]!=0 && bordfxd[idxtgt]){	//thi
s icaon is same as up && not balnk 						if (bordLnk[idxtgt]==0 && bordLnk[idx]=
=0){	//no links yet  							Lnkct++;	//create new link 							bordLnk[idx]=Lnkct
;	//and assign 							bordLnk[idxtgt]=Lnkct;	//to both 							} 						else{	//on
e of them or both have links 							if (bordLnk[idx]!=0 && bordLnk[idxtgt]==0)	/
/tgtidx have no link  								bordLnk[idxtgt]=bordLnk[idx]; 							else
 if	(bordLnk[idx]==0 && bordLnk[idxtgt]!=0)	//idx have no link  								bordLnk[
idx]=bordLnk[idxtgt]; 							else{	//lnk not same make new link number 								L
nkct++;	//create new linknumber 								lnkchange(bordLnk[idxtgt],Lnkct);	//chan
ge the bordlnk of TGT to new lnkct 								lnkchange(bordLnk[idx],Lnkct);		//cha
nge the bordlnk of IDX to new lnkct 								} 							} 						} 					} 				if
 (x!=bordXct){	//not yet rytmost, link to ryt 					idxtgt=getbordIdx(x+1,y);
 					if (bordicon[idxtgt]==bordicon[idx] && bordicon[idx]!=0 && bordfxd[idxtgt]
){	//this icaon is same as up && not balnk 						if (bordLnk[idxtgt]==0
 && bordLnk[idx]==0){	//uppertarget no links yet  							Lnkct++;	//create
 new link 							bordLnk[idx]=Lnkct; 							bordLnk[idxtgt]=Lnkct; 							}
 						else{	//upper tgt already linkd 							if (bordLnk[idx]!=0 && bordLnk[idx
tgt]==0)	//tgtidx have no link  								bordLnk[idxtgt]=bordLnk[idx]; 							els
e if	(bordLnk[idx]==0 && bordLnk[idxtgt]!=0)	//idx have no link  								bordLnk
[idx]=bordLnk[idxtgt]; 							else{	//lnk not same make new link number
 								Lnkct++; 								lnkchange(bordLnk[idxtgt],Lnkct); 								lnkchange(bo
rdLnk[idx],Lnkct); 								} 							} 						} 					} 				} 		
\end_layout

\begin_layout Plain Layout

		//	else	//not fixd, floating or icon=0, no need to traverse, break to
 next x 		//		break; 			} 		} 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

public void lnkchange(int lnkfrm,int lnkto){	//change the link number of
 a into b ..
 self explanatory :) 	int i; 	for (i=0;i<bordct;i++){ 		if (bordLnk[i]==lnkfrm)
 			bordLnk[i]=lnkto; 		} 	}
\end_layout

\begin_layout Plain Layout

public void moveallDwn(){	//move all icons down 	int i; 	for (i=0;i<bordct;i++){
 		if (!bordfxd[i] && bordicon[i]!=0){		//if not yet fixd and icon not blank
 			if (chkUnder(bordX[i],bordY[i])){		//if there is something under, make
 it fixd 				bordfxd[i]=true; 				} 			else{		//theres nothing beneath,
 move this to there 				moveiconDwn(bordX[i],bordY[i]); 				} 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void makeFloat(){	//chacks the highest pt of each columns and make
 the remaining float 	int x,y,z; 	boolean nomore; 	for (x=1;x<=bordXct;x++){	//l
oop bord width 		nomore=false; 		for (y=1;y<=bordYct;y++){	//loop bord ht
 			z=getbordIdx(x,y);	//get index of (x,y) 			if (!bordfxd[z] && !nomore)	//if
 this ht unfxd, make all succeeding unfxd 				nomore=true; 			if (nomore)
 				bordfxd[z]=false; 			} 		} 	}
\end_layout

\begin_layout Plain Layout

public void newCaps(){	//generates a new capsule 	cap1=getRandIcon(); 	cap2=getR
andIcon(); 	isderCaps=true; 	}
\end_layout

\begin_layout Plain Layout

public boolean transCaps(){	//transfercaps to bord 	capsDxn=3; 	int x,y,z;
 	z=bordXct/2; 	x=getbordIdx(z,bordYct); 	if (bordfxd[x])	//already fxd?
 		return false;	//u cant create new capsule 	y=getbordIdx(z+1,bordYct);
 	if (bordfxd[y])	 		return false; 	
\end_layout

\begin_layout Plain Layout

	bordpvt[x]=true;	//make this PVT 	bordcapsule[x]=true;	//and caps 	bordicon[x]=
cap1;	//get a random icon color 	bordcapsule[y]=true;	//make this caps 	bordicon
[y]=cap2; 	isderCaps=false; 	return true; 	}
\end_layout

\begin_layout Plain Layout

public int getIdxpvt(){	//gets the index of PVT 	int i; 	for (i=0;i<bordct;i++){
 		if (bordpvt[i] && bordcapsule[i])	//if this is PVT and this is also caps
 			break; 		} 	return i; 	}
\end_layout

\begin_layout Plain Layout

public int getIdxodr(){	//get ODR index 	int i; 	for (i=0;i<bordct;i++){
 		if (!bordpvt[i] && bordcapsule[i])	//this is not PVT "but" caps 			break;
 		} 	return i; 	}
\end_layout

\begin_layout Plain Layout

public int getRandIcon(){	//:) 	return (int)((Math.random()*100)%4)+1; 	}
\end_layout

\begin_layout Plain Layout

public boolean chkFloat(){	//check if there are still floating 	int i; 	for
 (i=0;i<bordct;i++){ 		if (bordicon[i]!=0 && !bordfxd[i])	//if not fxd but
 not blank 			return true; 		} 	return false; 	}
\end_layout

\begin_layout Plain Layout

public int getbordIdx(int inX, int inY){	//returns the index of (x,y) 	return
 (((inY-1)*bordXct)+inX)-1; 	}
\end_layout

\begin_layout Plain Layout

public boolean chkUnder(int inbordX,int inbordY){	//check if under of (x,y)
 is fixed or floor 	if (inbordY==1)	//on lowest row? 		return true; 	int
 lowbrd,bordidx; 	lowbrd=inbordY-1;	//get the under y 	bordidx=getbordIdx(inbord
X,lowbrd);	//get the under idx 	if (bordfxd[bordidx])	//if it is fixed 		return
 true; 	return false; 	}
\end_layout

\begin_layout Plain Layout

public void moveiconDwn(int inX, int inY){	//moves the icon of current (x,y)
 down 	int lowbrd,bordidx; 	lowbrd=inY-1; 	bordidx=getbordIdx(inX,lowbrd);
 	bordicon[bordidx]=bordicon[getbordIdx(inX,inY)]; 	bordicon[getbordIdx(inX,inY)
]=0; 	}
\end_layout

\begin_layout Plain Layout

public void drwBorder(Graphics2D sorpes){	//draws the lines 	//vertical
 	drwLine(bordLft-3,bordTop-3,bordLft-3,bordTop+bordPY+3,sorpes); 	drwLine(bordL
ft+bordPX+3,bordTop-3,bordLft+bordPX+3,bordTop+bordPY+3,sorpes); 	//drwLine(7,37
,7,403,sorpes); 	//drwLine(193,37,193,403,sorpes); 	//horisontal 	drwLine(bordLf
t-3,bordTop-3,(scrWD/2)-iconz,bordTop-3,sorpes); 	drwLine((scrWD/2)+iconz,bordTo
p-3,bordLft+bordPX+3,bordTop-3,sorpes); 	drwLine(bordLft-3,bordTop+bordPY+3,bord
Lft+bordPX+3,bordTop+bordPY+3,sorpes); 	//drwLine(7,37,70,37,sorpes); 	//drwLine
(130,37,193,37,sorpes); 	//drwLine(7,403,193,403,sorpes); 	}
\end_layout

\begin_layout Plain Layout

public void drwLine(int X,int Y,int x,int y,Graphics2D sorpes){ //print
 borderlines 	if (x==X){ //vertical line 		sorpes.setColor(Color.white); 		sorpes.d
rawLine(X,Y,x,y); 		sorpes.drawLine(X-1,Y+1,x-1,y-1); 		sorpes.drawLine(X-2,Y+2,x-
2,y-2);		 		sorpes.setColor(Color.gray); 		sorpes.drawLine(X+1,Y+1,x+1,y-1);
 		sorpes.drawLine(X+2,Y+2,x+2,y-2); 		} 	if (y==Y){ //horizontal 		sorpes.setColo
r(Color.white); 		sorpes.drawLine(X,Y,x,y); 		sorpes.drawLine(X+1,Y-1,x-1,y-1);
 		sorpes.drawLine(X+2,Y-2,x-2,y-2); 		sorpes.setColor(Color.gray); 		sorpes.drawLin
e(X+1,Y+1,x-1,y+1); 		sorpes.drawLine(X+2,Y+2,x-2,y+2); 		} 	}
\end_layout

\begin_layout Plain Layout

public void keyPressed(KeyEvent ke){ 	int kcode=gg=ke.getKeyCode();	//get
 the key code 	if (!ismovedelay && canCtrlCaps && isPlay){	//if u can control
 the capsule and not move delay 		movedelayStrt=System.currentTimeMillis();
 		if (kcode==100){	//numpad 4 			movedelay=50; 			toLft=true;		//moveleft
 			} 		if (kcode==101){	//numpad 5 			dwnTym=50;		//movedown a bit faster
 			} 		if (kcode==102){	//numpad 6 			movedelay=50; 			toRyt=true;		//moveryt
 			} 		if (kcode==103){	//numpad 7 			movedelay=50; 			rot8L=true;		//rot8left
 			} 		if (kcode==104){	//numpad 8 			movedelay=50; 			toSwc=true;		//switch
 places; 			} 		if (kcode==105){	//numpad 9 			movedelay=50; 			rot8R=true;		//r
ot8ryt 			} 		ismovedelay=true;	//delay the move 		return; 		} 	if (kcode==10){
 		if (isOver && !isStart){ 			isStart=true; 			isOver=false; 			} 		else
 if (isStart && !isPlay){ 			initGame(); 			isPlay=true; 			isStart=false;
 			} 		} 	} public void keyTyped(KeyEvent ke){} public void keyReleased(KeyEven
t ke){ 	if (canCtrlCaps)	//if u can control caps 		dwnTym=dwnTymHoldr;	//reset
 the dwntym to held tym 	} }
\end_layout

\end_inset


\end_layout

\begin_layout Part
Rootkit-lms v3 (learning management system of a study institute, Alpha classes
 in this particular case)
\end_layout

\begin_layout Standard
(2009-2013)
\end_layout

\begin_layout Part
Vik the Legend ( A 3D Game )
\end_layout

\begin_layout Standard
(2018 via Unity) The earth was made working by Taya Tayi ( Jagjeet Manjeet
 )
\end_layout

\begin_layout Part
A junior project ( init function of a Jquery html design )
\end_layout

\begin_layout Standard
Programmed by Sher1.0 on Suraj's request although he didn't program the 3rd
 level loop.
 (2017) Script Installed and html written by Saloni ( maami-shivi duo )
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

/*****************************************************************/ /* 5grid
 0.3.2 by n33.co | MIT+GPLv2 license licensed            */ /* init.js: Init
 script                                          */ /***************************
**************************************/
\end_layout

\begin_layout Plain Layout

/*********************/ /* Object Setup      */ /*********************/
\end_layout

\begin_layout Plain Layout

	var _5gridC = function() 	{ 		this.events = new Array();
\end_layout

\begin_layout Plain Layout

		this.isReady = false; 		this.isMobile = false; 		this.isDesktop = false;
 		this.isFluid = false; 		this.is1000px = false; 		this.is1200px = false;
 	}
\end_layout

\begin_layout Plain Layout

	_5gridC.prototype.bind = function(name, f) 	{ 		if (!this.events[name]) 			this.eve
nts[name] = new Array(); 	
\end_layout

\begin_layout Plain Layout

		this.events[name].push(f); 	}
\end_layout

\begin_layout Plain Layout

	_5gridC.prototype.trigger = function(name) 	{ 		if (!this.isReady || !this.events[n
ame] || this.events[name].length < 1) 			return; 		
\end_layout

\begin_layout Plain Layout

		for (i in this.events[name]) 			(this.events[name][i])(); 	}
\end_layout

\begin_layout Plain Layout

	_5gridC.prototype.ready = function(f) { this.bind('ready', f); } 	_5gridC.prototype.
orientationChange = function(f) { this.bind('orientationChange', f); } 	_5gridC.pr
ototype.mobileUINavOpen = function(f) { this.bind('mobileUINavOpen', f); }
 	_5gridC.prototype.mobileUINavClose = function(f) { this.bind('mobileUINavClose',
 f); }
\end_layout

\begin_layout Plain Layout

	_5gridC.prototype.readyCheck = function() 	{ 		var x = this; 	
\end_layout

\begin_layout Plain Layout

		window.setTimeout(function() { 			if (x.isReady) 				x.trigger('ready');
 			else 				x.readyCheck(); 		}, 50); 	}
\end_layout

\begin_layout Plain Layout

	var _5grid = new _5gridC;
\end_layout

\begin_layout Plain Layout

(function() {
\end_layout

\begin_layout Plain Layout

/*********************/ /* Initialize        */ /*********************/
\end_layout

\begin_layout Plain Layout

	// Vars 		var	_baseURL, _opts, 			_fluid, _1000px, _1200px, _mobile, _desktop,
 _mobileOnly, 			_window = jQuery(window), _head = jQuery('head'), _document
 = jQuery(document), 			_headQueue = new Array(), _isLocked = false, _isTouch
 = !!('ontouchstart' in window), _eventType = (_isTouch ? 'touchend' : 'click'),
 			v, w, x, y;
\end_layout

\begin_layout Plain Layout

	// Shortcut methods 		_headQueue.pushI_5grid = function(s) { _headQueue.push({
 type: 'i', value: s }); }; 		_headQueue.pushE_5grid = function(s) { _headQueue.pu
sh({ type: 'e', value: s }); };  		_headQueue.process_5grid = function()
 { 			var doE; 			if (document.createStyleSheet) 				doE = function(s) {
 document.createStyleSheet(s); }; 			else 				doE = function(s) { _head.append('<l
ink rel="stylesheet" href="' + s + '" />'); };
\end_layout

\begin_layout Plain Layout

			for (x in _headQueue) 			{ 				if (_headQueue[x].type == 'i') 					_head.append
('<style>' + _headQueue[x].value + '</style>'); 				else if (_headQueue[x].type
 == 'e') 					(doE)(_headQueue[x].value); 			} 		}; 		jQuery.fn.disableSelection_5g
rid = function() { return jQuery(this).css('user-select', 'none').css('-khtml-user
-select', 'none').css('-moz-user-select', 'none').css('-o-user-select', 'none').css
('-webkit-user-select', 'none'); } 		jQuery.fn.enableSelection_5grid = function()
 { return jQuery(this).css('user-select', 'auto').css('-khtml-user-select',
 'auto').css('-moz-user-select', 'auto').css('-o-user-select', 'auto').css('-webkit
-user-select', 'auto'); } 		jQuery.fn.accelerate_5grid = function() { return
 jQuery(this).css('-webkit-transform', 'translateZ(0)').css('-webkit-backface-visi
bility', 'hidden').css('-webkit-perspective', '1000'); }
\end_layout

\begin_layout Plain Layout

	// Determine base URL, opts 		x = jQuery('script').filter(function() { return
 this.src.match(/5grid
\backslash
/init
\backslash
.js/); }).first(); 		y = x.attr('src').split('?'); 		_baseURL = y[0].replace(/5grid
\backslash
/init
\backslash
.js/, ''); 		_opts = new Array();
\end_layout

\begin_layout Plain Layout

		// Default opts 			_opts['use'] = 'mobile,desktop'; 			_opts['prefix']
 = 'style'; 			_opts['mobileUI'] = 0; 			_opts['mobileUI.force'] = 0; 			_opts['m
obileUI.titleBarHeight'] = 44; 			_opts['mobileUI.titleBarOverlaid'] = 0;
 			_opts['mobileUI.openerWidth'] = 60; 			_opts['mobileUI.openerText'] =
 '='; 			_opts['mobileUI.titleBarFixed'] = 1; 			_opts['mobileUI.theme'] =
 'beveled'; 			_opts['mobileUI.themeTitleBarColor'] = '#444444'; 			_opts['mobile
UI.themeNavColor'] = '#272727'; 			_opts['mobileUI.hideAddressBar'] = 0; 			_opts[
'viewport.is1000px'] = 1040; 			_opts['viewport.is1200px'] = 1280; 			_opts['debug.
noExtLoad'] = 0;
\end_layout

\begin_layout Plain Layout

		// Custom opts 			if (y.length > 1) 			{  				x = y[1].split('&'); 				for
 (v in x) 				{ 					w = x[v].split('='); 					_opts[w[0]] = w[1]; 				}
 			} 
\end_layout

\begin_layout Plain Layout

	// Debug options 		if (_opts['debug.noExtLoad'] == 1) 			_headQueue.pushE_5grid
 = function(s) { }; 
\end_layout

\begin_layout Plain Layout

	// Determine viewing modes 		_desktop = _mobile = _fluid = _1000px = _1200px
 = _mobileOnly = false; 		v = _opts['use'].split(','); 	
\end_layout

\begin_layout Plain Layout

		if (jQuery.inArray('fluid', v) > -1) 			_fluid = true; 		if (jQuery.inArray('des
ktop', v) > -1) 			_desktop = true; 		if (jQuery.inArray('1000px', v) > -1)
 			_1000px = true; 		if (jQuery.inArray('1200px', v) > -1) 			_1200px =
 true; 		if (jQuery.inArray('mobile', v) > -1) 			_mobile = true;
\end_layout

\begin_layout Plain Layout

		if (_mobile && !_fluid && !_1000px && !_1200px && !_desktop) 			_mobileOnly
 = true; 			//_desktop = true;
\end_layout

\begin_layout Plain Layout

/*********************/ /* Core              */ /*********************/
\end_layout

\begin_layout Plain Layout

	// Legacy IE fixes 		if (jQuery.browser.msie) 		{ 			// HTML5 Shiv 				if
 (jQuery.browser.version < 9) 					_head.append('<script type="text/javascript"
 src="' + _baseURL + '5grid/html5shiv.js" />');
\end_layout

\begin_layout Plain Layout

			// Versions that don't support CSS3 pseudo classes 				if (jQuery.browser.versi
on < 8) 				{ 					jQuery(function() { 						jQuery('.5grid, .5grid-layout,
 .do-5grid').after('<div style="clear: both;"></div>'); 					}); 				} 		}
\end_layout

\begin_layout Plain Layout

	// Insert stylesheets 		_headQueue.pushE_5grid(_baseURL + '5grid/core.css')
 		_headQueue.pushE_5grid(_baseURL + _opts['prefix'] + '.css');
\end_layout

\begin_layout Plain Layout

/*********************/ /* Responsive        */ /*********************/
\end_layout

\begin_layout Plain Layout

	(function() { 		var ww = _window.width(), sw = screen.width, orientation
 = window.orientation;
\end_layout

\begin_layout Plain Layout

		// Fix: On iOS, screen.width is always the width of the device held in
 portrait mode.
 		// Android, however, sets it to the width of the device in its current
 orientation.
 		// This ends up breaking our detection on HD devices held in landscape
 mode, so we 		// do a little trick here to detect this condition and make
 things right.
 		if (screen.width > screen.height 		&&	Math.abs(orientation) == 90) 			sw
 = screen.height;
\end_layout

\begin_layout Plain Layout

		// Mobile (exclusive) 		if ((_mobile && (ww <= 480 || sw <= 480)) || _mobileOn
ly) 		{ 			_5grid.isMobile = true; 			_head.prepend('<meta name="viewport"
 content="initial-scale=1.0; minimum-scale=1.0; maximum-scale=1.0;" />'); 			_headQ
ueue.pushE_5grid(_baseURL + '5grid/core-mobile.css'); 		
\end_layout

\begin_layout Plain Layout

			if (_opts['mobileUI'] == 1) 			{ 				_opts['mobileUI.force'] = 1;
\end_layout

\begin_layout Plain Layout

				if (_opts['mobileUI.theme'] != 'none') 				{ 					_headQueue.pushE_5grid(_base
URL + '5grid/mobileUI-' + _opts['mobileUI.theme'] + '.css');
\end_layout

\begin_layout Plain Layout

					if (_opts['mobileUI.themeTitleBarColor']) 						_headQueue.pushI_5grid('#mobi
leUI-site-titlebar { background: ' + _opts['mobileUI.themeTitleBarColor']
 + '; }');
\end_layout

\begin_layout Plain Layout

					if (_opts['mobileUI.themeNavColor']) 						_headQueue.pushI_5grid('#mobileUI-
site-nav { background: ' + _opts['mobileUI.themeNavColor'] + '; }'); 				}
 			}
\end_layout

\begin_layout Plain Layout

			_headQueue.pushE_5grid(_baseURL + _opts['prefix'] + '-mobile.css'); 		}
 		else 		{ 			// Fluid (exclusive) 			if (_fluid) 			{ 				_5grid.isFluid
 = true; 				_head.prepend('<meta name="viewport" content="width=' + _opts['viewp
ort.is1200px'] + '" />'); 				_headQueue.pushE_5grid(_baseURL + '5grid/core-deskto
p.css'); 				_headQueue.pushE_5grid(_baseURL + '5grid/core-fluid.css'); 				_headQu
eue.pushE_5grid(_baseURL + _opts['prefix'] + '-fluid.css'); 			} 			// Desktop
 			else if (_desktop) 			{ 				_5grid.isDesktop = true; 				_headQueue.pushE_5gri
d(_baseURL + '5grid/core-desktop.css'); 				_headQueue.pushE_5grid(_baseURL
 + _opts['prefix'] + '-desktop.css'); 		
\end_layout

\begin_layout Plain Layout

				// 1200px 				if (ww >= 1200) 				{ 					_5grid.is1200px = true; 					_head.pr
epend('<meta name="viewport" content="width=' + _opts['viewport.is1200px']
 + '" />'); 					_headQueue.pushE_5grid(_baseURL + '5grid/core-1200px.css');
 				
\end_layout

\begin_layout Plain Layout

					// Load 1200px stylesheet if 1200px was explicitly enabled 					if
 (_1200px) 						_headQueue.pushE_5grid(_baseURL + _opts['prefix'] + '-1200px.css'
); 				} 				// 1000px 				else 				{ 					_5grid.is1000px = true; 					_head.prep
end('<meta name="viewport" content="width=' + _opts['viewport.is1000px']
 + '" />'); 					_headQueue.pushE_5grid(_baseURL + '5grid/core-1000px.css');
\end_layout

\begin_layout Plain Layout

					// Load 1000px stylesheet if 1000px was explicitly enabled 					if
 (_1000px) 						_headQueue.pushE_5grid(_baseURL + _opts['prefix'] + '-1000px.css'
); 				} 			} 			else 			{ 				// 1000px (exclusive) 				if (_1000px &&
 (ww < 1200 || !_1200px)) 				{ 					_5grid.isDesktop = true; 					_5grid.is1000px
 = true; 					_head.prepend('<meta name="viewport" content="width=' + _opts['view
port.is1000px'] + '" />'); 					_headQueue.pushE_5grid(_baseURL + '5grid/core-desk
top.css'); 					_headQueue.pushE_5grid(_baseURL + '5grid/core-1000px.css');
 					_headQueue.pushE_5grid(_baseURL + _opts['prefix'] + '-1000px.css');
 				} 				// 1200px (exclusive) 				else if (_1200px && (ww >= 1200 ||
 !_1000px)) 				{ 					_5grid.isDesktop = true; 					_5grid.is1200px = true;
 					_head.prepend('<meta name="viewport" content="width=' + _opts['viewport.is12
00px'] + '" />'); 					_headQueue.pushE_5grid(_baseURL + '5grid/core-desktop.css')
; 					_headQueue.pushE_5grid(_baseURL + '5grid/core-1200px.css'); 					_headQueue.
pushE_5grid(_baseURL + _opts['prefix'] + '-1200px.css'); 				} 			} 		}
\end_layout

\begin_layout Plain Layout

		jQuery(function() { jQuery('.5grid-layout').addClass('5grid'); }); 	})();
\end_layout

\begin_layout Plain Layout

/*********************/ /* MobileUI          */ /*********************/
\end_layout

\begin_layout Plain Layout

	if (_opts['mobileUI.force'] == 1) 		jQuery(function() { 			var body = jQuery('bo
dy'), speed = 0, easing = 'swing'; 			var mobileUI_site_nav, mobileUI_site_nav_o
pener, mobileUI_site_titlebar, mobileUI_site_wrapper, mobileUI_site_group;
 	
\end_layout

\begin_layout Plain Layout

			body.wrapInner('<div id="mobileUI-site-wrapper" />'); 	
\end_layout

\begin_layout Plain Layout

			// Move primary content 				var main_content = jQuery('.mobileUI-main-content'
), main_content_target = jQuery('.mobileUI-main-content-target'); 			
\end_layout

\begin_layout Plain Layout

				if (main_content.length > 0) 					if (main_content_target.length > 0)
 						main_content.prependTo(main_content_target); 					else 						main_content.p
rependTo(main_content.parent()); 	
\end_layout

\begin_layout Plain Layout

			// Get site name, nav options 				var x = jQuery('.mobileUI-site-name'),
 site_name = (x.length > 0 ? x.html() : ''); 				var site_nav_options = new
 Array(); 			
\end_layout

\begin_layout Plain Layout

				jQuery('.mobileUI-site-nav a').each(function() { 					var t = jQuery(this),
 indent; 					indent = Math.max(0,t.parents('li').length - 1); 					site_nav_option
s.push( 						'<a href="' + t.attr('href') + '"><span class="indent-' + indent
 + '"></span>' + t.text() + '</a>' 					); 				});
\end_layout

\begin_layout Plain Layout

				if (site_nav_options.length > 0) 				{ 					mobileUI_site_nav = jQuery('<div
 id="mobileUI-site-nav"><nav>' + site_nav_options.join('') + '</nav></div>');
 					mobileUI_site_nav_opener = jQuery('<div id="mobileUI-site-nav-opener">'
 + _opts['mobileUI.openerText'] + '</div>'); 				} 				else 				{ 					mobileUI_s
ite_nav = jQuery(); 					mobileUI_site_nav_opener = jQuery(); 				}
\end_layout

\begin_layout Plain Layout

			// Configure elements 				mobileUI_site_titlebar = jQuery('<div id="mobileUI-
site-titlebar"><div id="mobileUI-site-title">' + site_name + '</div></div>');
 				mobileUI_site_wrapper = jQuery('#mobileUI-site-wrapper'); 				mobileUI_site
_group = jQuery().add(mobileUI_site_wrapper).add(mobileUI_site_titlebar);
\end_layout

\begin_layout Plain Layout

				body.bind('touchmove', function(e) { 					if (mobileUI_site_nav.isOpen_5grid)
 					{ 						e.stopPropagation(); 						e.preventDefault(); 					} 				});
\end_layout

\begin_layout Plain Layout

				// Mobile Site Wrapper 					mobileUI_site_wrapper 						.css('position',
 'relative') 						.css('z-index', '100') 						.css('top', (_opts['mobileUI.titleB
arOverlaid'] == 1 ? 0 : _opts['mobileUI.titleBarHeight'] + 'px')) 						.css('widt
h', '100%') 						.bind(_eventType, function(e) { 							if (mobileUI_site_nav.isO
pen_5grid) 							{ 								e.preventDefault(); 								body.trigger('5grid_closeN
av'); 							} 						}) 						.bind('5grid_top', function(e) { 							if
 (_isLocked) 								return; 							_isLocked = true; 							body.animate({
 scrollTop: 0 }, 400, 'swing', function() { _isLocked = false; }); 						});
\end_layout

\begin_layout Plain Layout

				// Mobile Site Nav Opener 					mobileUI_site_nav_opener 						.css('position'
, 'absolute') 						.css('z-index', '152') 						.css('cursor', 'pointer')
 						.disableSelection_5grid() 						.appendTo(mobileUI_site_titlebar) 						.bin
d(_eventType, function(e) { 							e.stopPropagation(); 							e.preventDefault();
 							body.trigger('5grid_toggleNav'); 						}); 					
\end_layout

\begin_layout Plain Layout

				// Mobile Site Bar 					mobileUI_site_titlebar 						.css('position',
 (_opts['mobileUI.titleBarFixed'] == 1 ? 'fixed' : 'absolute')) 						.css('z-inde
x', '151') 						.css('top', '0') 						.css('width', '100%') 						.css('overflow'
, 'hidden') 						.css('height', _opts['mobileUI.titleBarHeight'] + 'px')
 						.css('line-height', _opts['mobileUI.titleBarHeight'] + 'px') 						.disableS
election_5grid() 						.prependTo(body); 					
\end_layout

\begin_layout Plain Layout

				// Mobile Site Nav 					mobileUI_site_nav 						.css('position', 'fixed')
 						.css('z-index', '150') 						.css('top', '0') 						.css('height', '100%')
 						.disableSelection_5grid() 						.prependTo(body);
\end_layout

\begin_layout Plain Layout

					mobileUI_site_nav 						.css('left', -1 * mobileUI_site_nav.width())
 						.hide() 						.click(function(e) { 							e.stopPropagation(); 						});
 					
\end_layout

\begin_layout Plain Layout

					mobileUI_site_nav.find('a') 						.click(function(e) { 							e.preventDefault
(); 							e.stopPropagation(); 							body.trigger('5grid_closeNav', [jQuery(this
).attr('href')]); 						});
\end_layout

\begin_layout Plain Layout

					if (_isTouch) { 						var _mobileUI_site_nav_pos = 0; 						mobileUI_site_n
av 							.css('overflow', 'hidden') 							.bind('touchstart', function(e)
 { 								_mobileUI_site_nav_pos = mobileUI_site_nav.scrollTop() + event.touches[
0].pageY; 							}) 							.bind('touchmove', function(e) { 								e.preventDefaul
t(); 								e.stopPropagation(); 								mobileUI_site_nav.scrollTop(_mobileUI_si
te_nav_pos - event.touches[0].pageY); 							}); 					} 					else 						mobileUI_s
ite_nav.css('overflow', 'auto');
\end_layout

\begin_layout Plain Layout

					mobileUI_site_nav.isOpen_5grid = false;
\end_layout

\begin_layout Plain Layout

				// Body 					body	 						.css('overflow', (_isTouch ? 'hidden' : 'visible'))
 						.bind('5grid_toggleNav', function() { 							if (mobileUI_site_nav.isOpen_5
grid) 								body.trigger('5grid_closeNav'); 							else 								body.trigger('5g
rid_openNav'); 						}) 						.bind('5grid_openNav', function() { 							if
 (_isLocked) 								return true; 							_isLocked = true; 							var nw
 = jQuery(window).width() - _opts['mobileUI.openerWidth']; 							mobileUI_site_gr
oup 								.css('width', jQuery(window).width()) 								.disableSelection_5grid()
; 							mobileUI_site_nav 								.show() 								.scrollTop(0) 								.css('widt
h', nw) 								.css('left', -1 * nw); 							mobileUI_site_nav.animate({
 left: 0 }, speed, easing); 							mobileUI_site_group.animate({ left: nw
 }, speed, easing, function() { 								_isLocked = false; 								mobileUI_site
_nav.isOpen_5grid = true; 								_5grid.trigger('mobileUINavOpen'); 							});
 						}) 						.bind('5grid_closeNav', function(e, url) { 							if (_isLocked)
 								return true; 							_isLocked = true; 							var nw = mobileUI_site_nav.
width(); 							mobileUI_site_nav.animate({ left: -1 * nw }, speed, easing);
 							mobileUI_site_group.animate({ left: 0 }, speed, easing, function()
 { 								mobileUI_site_group 									.css('width', '100%') 									.css('overf
low', 'visible') 									.enableSelection_5grid(); 								mobileUI_site_wrapper.
css('position', 'relative'); 								mobileUI_site_titlebar.css('position',
 (_opts['mobileUI.titleBarFixed'] == 1 ? 'fixed' : 'absolute')); 								mobileUI
_site_nav.isOpen_5grid = false; 								mobileUI_site_nav.hide(); 								_5grid.tr
igger('mobileUINavclose'); 								_isLocked = false; 							
\end_layout

\begin_layout Plain Layout

								if (url) 									window.setTimeout(function() { 										window.location.
href = url; 									}, 150); 							}); 						}); 			
\end_layout

\begin_layout Plain Layout

					// Window 						_window 							.bind('orientationchange', function(e)
 { 								if (mobileUI_site_nav.isOpen_5grid) { 									var nw = jQuery(window).
width() - _opts['mobileUI.openerWidth']; 									mobileUI_site_nav.css('width',
 nw); 									mobileUI_site_group.css('left', nw); 								} 								_5grid.trigg
er('orientationChange'); 							}); 			
\end_layout

\begin_layout Plain Layout

			// Remove mobileUI-hide elements 				jQuery('.mobileUI-hide').remove();
 			
\end_layout

\begin_layout Plain Layout

			// Remove address bar 				if (_opts['mobileUI.hideAddressBar'] == 1 &&
 _window.scrollTop() == 0) 					window.scrollTo(0, 1); 		});
\end_layout

\begin_layout Plain Layout

/*********************/ /* Head Queue        */ /*********************/
\end_layout

\begin_layout Plain Layout

	_headQueue.process_5grid(); 	_5grid.isReady = true;
\end_layout

\begin_layout Plain Layout

	jQuery(function() { _5grid.readyCheck(); });
\end_layout

\begin_layout Plain Layout

})();
\end_layout

\end_inset


\end_layout

\end_body
\end_document
